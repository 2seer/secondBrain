---
created: ["2022-06-24 20:37"]
aliases: []
tags: []
start_read_page: 310
finish_read_page: 323
comments: true
---

# 220630 스터디
## 작성일 : [[2022-06-24]]
## 상위 문서 : [[Real MySQL]]
## 분야 : #SQL
## 키워드 : #옵티마이저와_힌트
## 상태 :  #작성중, #연결중 

![[Pasted image 20220624234215.png]]

## 9.2.5 DISTINCT 처리
> 특정 칼럼의 유니크한 값만 조회하려면 SELECT 쿼리에 DISTINCT를 사용한다. 

## 영향도
### 집계함수 유무에 따라 DISTINCT의 영향이 달라진다고 한다.

#### 1. 집계함수가 없는 경우
- ##### DISTINCT는  단순히 유니크한 레코드만 가져오고자 하는 경우에는 GROUP BY와 동일한 방식으로 처리가 되기는 하지만, 정렬이 되지 않는다는 차이가 있다.
- ##### 정렬 작업이 필요하지 않는다면 DISTINCT를 사용하는 것이 성능상 더 빠르다 할 수 있다.
```Mysql
SELECT DISTINCT emp_no FROM salaries;

SELECT emp_no FROM salaries GROUP BY emp_no;
```

- ####  주의할 것은  DISTINCT는 SELECT 되는 모든  컬럼들을 유니크하게  조회하는 것이지 컬럼을 조건하에 유니크하게 조회하는 것이 아니라는 점이다.
```MySql
SELECT DISTINCT first_name, last_name FROM employees; #1 쿼리

SELECT DISTINCT (first_name), last_name FROM employees; #2 쿼

# #2 쿼리는 first_name만 유니크하게 조회하고 last_name은 동일하게 조회하는 쿼리처림 보인다.
# 해당 쿼리는 에러 없이 실행되기 때문에 실수할 수 있는 부분이지만,
# MySQL은 DISTINCT라는 키워드가 있으면, SELECT되는 모든 컬럼들에 대해 DISTINCT를 적용하여 결과를 처리한다.
# 따라서 first_name만 유니크하게, last_name은 동일하게 조회하려고 한다면 GROUP BY로만 해결이 가능하다.
SELECT first_name, last_name FROM employees GROUP BY first_name;
```

#### 2.  집계 함수(COUNT, SUM, AVG, MIN, MAX, STDDEV, VARIANCE)와 함께 사용되는 경우
- 집합 함수 내에서 아용된 DISTINCT는 그 집합 함수의 인자로 전달된 칼럼값 들 중 중복을 제거하거 남은 값들을 가져온다.
| id | select_type | table | type  | key     | key_len | ref      | rows | extra                    |
|:---|:------------|:------|:------|:--------|:--------|:---------|:-----|:-------------------------|
|  1 | SIMPLE      | e     | range | PRIMARY |       4 |          |  100 | Using where; Using index |
|  1 | SIMPLE      | s     | ref   | PRIMARY |       4 | e.emp_no |    4 |                          |  

```Mysql
EXPLAIN 
SElECT COUNT(DISTINCT s.salary) 
FROM employees e, salaries s 
WHERE e.emp_no = s.emp_no 
    AND e.emp_no BETWEEN 100001 AND 100100;


#### 위 쿼리는 employees 테이블과 salaries 테이블을 조인한 결과에서 salary 칼럼의 값만 저장하기 위해 임시테이블을 생성한다.
#### 임시테이블을 사용하지만 실행 계획에서는 임시 테이블을 사용한다는 메세지는 표시되지 않는다.
#### 임시테이블의 salary 컬럼에는 유니크 인덱스가 생성되기 때문에 레코드 건수가 많아지면 상당히 느려질 수 있는 형태의 쿼리이다.

#### 위의 쿼리에 COUNT(DISTINCT ..)를 하나 더 추가해보자
#### COUNT() 함수가 두번 사용된 다음 쿼리의 실행 계획은 위의 쿼리와 똑같이 표시가 된다. 하지만 다음 쿼리를 처리하려면 s.salary컬럼의 값을 저장하는 임시 테이블과 e.last_name 컬럼의 값을 저장하는 또 다른 임시테이블이 필요하므로 2개의 임시 테이블을 사용하게 된다.
```Mysql
EXPLAIN 
SElECT COUNT(DISTINCT s.salary),
	   COUNT(DISTINCT e.last_time)
FROM employees e, salaries s 
WHERE e.emp_no = s.emp_no 
    AND e.emp_no BETWEEN 100001 AND 100100;
```

#### 위의 쿼리들은 DISTINCT 처리를 위해 인덱스를 이용할 수 없어 임시 테이블이 필요했었는데, 아래 쿼리와 같이 인덱스된 컬럼에 대해 DISTINCT 처리를 수행할 때는 인덱스를 `풀 스캔`하거나 `레인지 스캔`을 하면서 임시 테이블 없이 최적화된 쿼리를 수행할 수 있다.
```MySQL
SELECT COUNT(DISTINCT emp_no) FROM employees;
SELECT COUNT(DISTINCT emp_no) FROM dept_emp GROUP BY dept_no;
```

| id | select_type | table | type  | key     | key_len | ref      | rows | extra                    |
|:---|:------------|:------|:------|:--------|:--------|:---------|:-----|:-------------------------|
|  1 | SIMPLE      | dept_emp     | range | PRIMARY |       16 |          |  334242 | Using index |


## 주석
---
- 1


## ⏱히스토리
	- 2022-06-24 16:54 최초 작성
